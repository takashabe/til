## クラスタインデックスとセカンダリインデックス

InnoDBではクラスタインデックスとセカンダリインデックスが採用されており、一部のキー(後述)とそれ以外の一般的に `create index` 文で作られるインデックスではデータの持ち方が異なる。

#### インデックスのデータ構造

クラスタインデックス、セカンダリインデックス共にデフォルトでは(B+木)[https://ja.wikipedia.org/wiki/B%2B%E6%9C%A8]で実装されている。
いずれも各ノードのキーはインデックスで保存されており、末端のリーフノードに格納されるデータが異なっている。

#### クラスタインデックス

* 使用されるキー

以下の優先順位でキーが採用される

1. 主キー
2. NOT NULLかつUNIQUEなカラム
3. 1, 2に該当しない場合のみ暗黙的に作られるキー

* リーフノードの格納される値
  * リーフノードにはレコードのデータ全てが保存されている

* メリット
  * データ自体が格納されているのでリーフノードの探索とデータのフェッチが同時に行える

* 注意点
  * 主キーがインデックスのキーに使われるので、例えばUUIDをキーにするとデータ量、更新時の負荷、リーフ分割などが起こる
  * auto_incrementのサロゲートキーを利用する場合はデータ量も少なく、キーの値が単純増加となり、ツリーのソートコストが削減される

#### セカンダリインデックス

* 使用されるキー
  * `create index` で作成したキー名

* リーフノードに格納される値
  * クラスタインデックスの該当キーへのポインタ
  * つまり暗黙的にクラスタインデックスのキー(主キー)がインデックスに追加されている形となる

* クラスタインデックスとの比較
  * 上述の通り目当てのデータはクラスタインデックスに入っている(除カバリングインデックス)
  * セカンダリインデックスで検索を行った場合、結局データを得るためにクラスタインデックスにアクセスするためI/O回数が増える
  * フェッチするデータがセカンダリインデックスのキーで全て賄っていれば、クラスタインデックスにアクセスせずに済む
    * カバリングインデックスと呼ばれる状態

#### 参考

* https://www.oreilly.co.jp/books/9784873116389/
* https://dev.mysql.com/doc/refman/5.6/ja/innodb-index-types.html
* http://nippondanji.blogspot.jp/2010/10/innodb.html
